import { ProjPointType } from '@noble/curves/abstract/weierstrass';
import { Buff } from '@cmdcode/buff-utils';
type ECPoint = ProjPointType<bigint>;
type FieldValue = string | number | bigint | Uint8Array | Field;
type PointValue = string | number | bigint | Uint8Array | Point;
export declare class Field extends Uint8Array {
    static N: bigint;
    static mod(x: bigint, n?: bigint): bigint;
    static pow(x: bigint, e: bigint, n?: bigint): bigint;
    static normalize(num: FieldValue): Uint8Array;
    static validate(num: bigint): boolean;
    constructor(x: FieldValue);
    get buff(): Buff;
    get raw(): Uint8Array;
    get big(): bigint;
    get hex(): string;
    get point(): Point;
    get xpoint(): Point;
    get hasOddY(): boolean;
    get negated(): Field;
    gt(big: FieldValue): boolean;
    lt(big: FieldValue): boolean;
    eq(big: FieldValue): boolean;
    ne(big: FieldValue): boolean;
    add(big: FieldValue): Field;
    sub(big: FieldValue): Field;
    mul(big: FieldValue): Field;
    pow(big: FieldValue): Field;
    div(big: FieldValue): Field;
    negate(): Field;
    generate(): Point;
}
export declare class Point {
    static N: bigint;
    static validate(x: PointValue): boolean;
    static normalize(x: PointValue): ECPoint;
    static generate(value: FieldValue): Point;
    static import(point: Point | ECPoint): Point;
    readonly __p: ECPoint;
    constructor(x: PointValue, y?: bigint);
    get p(): ECPoint;
    get x(): Buff;
    get y(): Buff;
    get buff(): Buff;
    get raw(): Uint8Array;
    get hex(): string;
    get hasEvenY(): boolean;
    get hasOddY(): boolean;
    eq(value: PointValue): boolean;
    add(x: PointValue): Point;
    sub(x: PointValue): Point;
    mul(value: PointValue): Point;
    negate(): Point;
}
export {};
//# sourceMappingURL=ecc.d.ts.map