import { Buff, Bytes } from '@cmdcode/buff-utils';
import { Field, Point } from './ecc.js';
import { getXOnlyPub } from './utils.js';
import { SignatureType } from './signer.js';
type KeyOptions = Partial<KeyConfig>;
interface KeyConfig {
    type: SignatureType;
}
export declare class SecretKey extends Uint8Array {
    static random(opt?: KeyOptions): SecretKey;
    readonly config: KeyConfig;
    readonly xonly: boolean;
    constructor(secret: Bytes, options?: KeyOptions);
    get buff(): Buff;
    get raw(): Uint8Array;
    get hex(): string;
    get field(): Field;
    get point(): Point;
    get pub(): PublicKey;
    get hasEvenY(): boolean;
    get hasOddY(): boolean;
    get xfilter(): SecretKey;
    add(bytes: Bytes): SecretKey;
    sub(bytes: Bytes): SecretKey;
    mul(bytes: Bytes): SecretKey;
    div(bytes: Bytes): SecretKey;
    pow(bytes: Bytes): SecretKey;
    negate(): SecretKey;
    sign(message: Bytes, type?: SignatureType): Uint8Array;
    verify(signature: Bytes, message: Bytes, type?: SignatureType): boolean;
    toWIF(prefix?: number): string;
}
export declare class PublicKey extends Uint8Array {
    static random(opt: KeyOptions): PublicKey;
    static fromSecret(bytes: Bytes, opt: KeyOptions): PublicKey;
    static xfilter: typeof getXOnlyPub;
    readonly config: KeyConfig;
    readonly xonly: boolean;
    constructor(pubkey: Bytes, options?: KeyOptions);
    get buff(): Buff;
    get raw(): Uint8Array;
    get hex(): string;
    get point(): Point;
    get x(): Buff;
    get y(): Buff;
    get hasEvenY(): boolean;
    get hasOddY(): boolean;
    add(bytes: Bytes): PublicKey;
    sub(bytes: Bytes): PublicKey;
    mul(bytes: Bytes): PublicKey;
    negate(): PublicKey;
    verify(signature: Bytes, message: Bytes, type?: SignatureType): boolean;
}
export declare const KeyPair: typeof SecretKey;
export {};
//# sourceMappingURL=keypair.d.ts.map