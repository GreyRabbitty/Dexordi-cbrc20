import * as C from './convert.js';
import { Bytes, Json } from './types.js';
type BufferLike = Buff | ArrayBuffer | ArrayBufferLike | Uint8Array | string | number | bigint | boolean;
type HashTypes = 'sha256' | 'hash256' | 'ripe160' | 'hash160';
type HmacTypes = 'hmac256' | 'hmac512';
type Endian = 'le' | 'be';
export declare class Buff extends Uint8Array {
    static num: (number: number, size?: number, endian?: Endian) => Buff;
    static big: (number: bigint, size?: number, endian?: Endian) => Buff;
    static bin: (data: string | number[], size?: number) => Buff;
    static any: (data: any, size?: number) => Buff;
    static raw: (data: ArrayBufferLike, size?: number) => Buff;
    static str: (data: string, size?: number) => Buff;
    static hex: (data: string, size?: number) => Buff;
    static json: (data: Json) => Buff;
    static base64: (data: string) => Buff;
    static b64url: (data: string) => Buff;
    static bech32: (data: string) => Buff;
    static b58chk: (data: string) => Buff;
    static bytes: (data: BufferLike, size?: number) => Buff;
    constructor(data: BufferLike, size?: number);
    get arr(): number[];
    get num(): number;
    get big(): bigint;
    get str(): string;
    get hex(): string;
    get raw(): Uint8Array;
    get bits(): number[];
    get bin(): string;
    get b58chk(): string;
    get base64(): string;
    get b64url(): string;
    get digest(): Buff;
    get id(): string;
    get stream(): Stream;
    toNum(endian?: Endian): number;
    toBig(endian?: Endian): bigint;
    toHash(type?: HashTypes): Buff;
    toHmac(key: Bytes, type?: HmacTypes): Buff;
    toStr(): string;
    toHex(): string;
    toJson(): Json;
    toBytes(): Uint8Array;
    toBits(): number[];
    toBin(): string;
    tob58chk(): string;
    toB64url(): string;
    toBase64(): string;
    toBech32(hrp: string, version?: number): string;
    prepend(data: BufferLike): Buff;
    append(data: BufferLike): Buff;
    slice(start?: number, end?: number): Buff;
    subarray(begin?: number, end?: number): Buff;
    reverse(): Buff;
    write(bytes: Uint8Array, offset?: number): void;
    prefixSize(endian?: Endian): Buff;
    static from(data: Uint8Array | number[]): Buff;
    static of(...args: number[]): Buff;
    static join(arr: BufferLike[]): Buff;
    static varInt(num: number, endian?: Endian): Buff;
    static encode: typeof C.strToBytes;
    static decode: typeof C.bytesToStr;
    static random(size?: number): Buff;
    static normalize(bytes: Bytes, size?: number): Buff;
    static hexify(bytes: Bytes): string;
    static serialize(data: any, size?: number): Buff;
    static revive(data: string): string;
    static stringify(obj: any): string;
    static parse(str: string): Json | any;
}
export declare class Stream {
    size: number;
    data: Uint8Array;
    constructor(data: ArrayBufferLike);
    peek(size: number): Buff;
    read(size: number): Buff;
    readSize(endian?: Endian): number;
}
export {};
//# sourceMappingURL=buff.d.ts.map