function joinArray(arr) {
    let i, idx = 0;
    const size = arr.reduce((prev, curr) => prev + curr.length, 0);
    const buff = new Uint8Array(size);
    for (const bytes of arr) {
        for (i = 0; i < bytes.length; idx++, i++) {
            buff[idx] = bytes[i];
        }
    }
    return buff;
}

function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
var assert$1 = assert;

const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
// For runtime check if class implements interface
let Hash$1 = class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
/**
 * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.
 */
function randomBytes(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === 'function') {
        return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}

// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends Hash$1 {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
    }
    update(data) {
        assert$1.exists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        assert$1.exists(this);
        assert$1.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}

// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
const sha256$1 = wrapConstructor(() => new SHA256());
wrapConstructor(() => new SHA224());

const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
var u64$1 = u64;

// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = u64$1.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n)));
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64$1.rotrSH(W15h, W15l, 1) ^ u64$1.rotrSH(W15h, W15l, 8) ^ u64$1.shrSH(W15h, W15l, 7);
            const s0l = u64$1.rotrSL(W15h, W15l, 1) ^ u64$1.rotrSL(W15h, W15l, 8) ^ u64$1.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64$1.rotrSH(W2h, W2l, 19) ^ u64$1.rotrBH(W2h, W2l, 61) ^ u64$1.shrSH(W2h, W2l, 6);
            const s1l = u64$1.rotrSL(W2h, W2l, 19) ^ u64$1.rotrBL(W2h, W2l, 61) ^ u64$1.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64$1.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64$1.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64$1.rotrSH(Eh, El, 14) ^ u64$1.rotrSH(Eh, El, 18) ^ u64$1.rotrBH(Eh, El, 41);
            const sigma1l = u64$1.rotrSL(Eh, El, 14) ^ u64$1.rotrSL(Eh, El, 18) ^ u64$1.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64$1.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64$1.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64$1.rotrSH(Ah, Al, 28) ^ u64$1.rotrBH(Ah, Al, 34) ^ u64$1.rotrBH(Ah, Al, 39);
            const sigma0l = u64$1.rotrSL(Ah, Al, 28) ^ u64$1.rotrBL(Ah, Al, 34) ^ u64$1.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64$1.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64$1.add3L(T1l, sigma0l, MAJl);
            Ah = u64$1.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64$1.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64$1.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64$1.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64$1.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64$1.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64$1.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64$1.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64$1.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
const sha512$1 = wrapConstructor(() => new SHA512());
wrapConstructor(() => new SHA512_224());
wrapConstructor(() => new SHA512_256());
wrapConstructor(() => new SHA384());

// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
const Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = new Uint32Array(16);
class RIPEMD160 extends SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
const ripemd160 = wrapConstructor(() => new RIPEMD160());

// HMAC (RFC 2104)
class HMAC extends Hash$1 {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        assert$1.hash(hash);
        const key = toBytes(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new TypeError('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        assert$1.exists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        assert$1.exists(this);
        assert$1.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

const ec$2 = new TextEncoder();
const dc = new TextDecoder();
function strToBytes(str) {
    return ec$2.encode(str);
}
function hexToBytes(str) {
    const bytes = new Uint8Array(str.length / 2);
    let i, idx = 0;
    if (str.match(/[^a-fA-f0-9]/) !== null) {
        throw new TypeError('Invalid hex string: ' + str);
    }
    if (str.length % 2 > 0) {
        throw new Error(`Hex string length is uneven: ${str.length}`);
    }
    for (i = 0; i < str.length; i += 2) {
        bytes[idx] = parseInt(str.slice(i, i + 2), 16);
        idx += 1;
    }
    return bytes;
}
function numToBytes(num) {
    if (num === 0)
        return Uint8Array.of(0x00);
    const bytes = [];
    while (num > 0) {
        const byte = num & 0xff;
        bytes.push(byte);
        num = (num - byte) / 256;
    }
    return new Uint8Array(bytes);
}
function binaryToBytes(binary) {
    if (typeof binary === 'string') {
        binary = binary.split('').map(Number);
    }
    else if (!Array.isArray(binary)) {
        throw new Error('Invalid input type: expected a string or an array of numbers.');
    }
    if (binary.length % 8 !== 0) {
        throw new Error(`Binary array is invalid length: ${binary.length}`);
    }
    const bytes = new Uint8Array(binary.length / 8);
    for (let i = 0, ct = 0; i < binary.length; i += 8, ct++) {
        let byte = 0;
        for (let j = 0; j < 8; j++) {
            byte |= (binary[i + j] << (7 - j));
        }
        bytes[ct] = byte;
    }
    return bytes;
}
function bytesToBinary(bytes) {
    const bin = new Array(bytes.length * 8);
    let count = 0;
    for (const num of bytes) {
        if (num > 255) {
            throw new Error(`Invalid byte value: ${num}. Byte values must be between 0 and 255.`);
        }
        for (let i = 7; i >= 0; i--, count++) {
            bin[count] = (num >> i) & 1;
        }
    }
    return bin;
}
function bigToBytes(big) {
    if (big === 0n)
        return Uint8Array.of(0x00);
    const bytes = [];
    while (big > 0n) {
        const byte = big & 0xffn;
        bytes.push(Number(byte));
        big = (big - byte) / 256n;
    }
    return new Uint8Array(bytes);
}
function bytesToStr(bytes) {
    return dc.decode(bytes);
}
function bytesToHex(bytes) {
    const chars = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        chars.push(bytes[i].toString(16).padStart(2, '0'));
    }
    return chars.join('');
}
function bytesToNum(bytes) {
    let num = 0, i;
    for (i = bytes.length - 1; i >= 0; i--) {
        num = (num * 256) + bytes[i];
    }
    return Number(num);
}
function bytesToBig(bytes) {
    let num = 0n, i;
    for (i = bytes.length - 1; i >= 0; i--) {
        num = (num * 256n) + BigInt(bytes[i]);
    }
    return BigInt(num);
}
function buffer(value, bytes = true) {
    if (value instanceof ArrayBuffer) {
        return new Uint8Array(value);
    }
    if (value instanceof Uint8Array) {
        return new Uint8Array(value);
    }
    switch (typeof value) {
        case 'bigint':
            return bigToBytes(value);
        case 'boolean':
            return Uint8Array.of(value ? 1 : 0);
        case 'number':
            return numToBytes(value);
        case 'string':
            return (bytes)
                ? hexToBytes(value)
                : ec$2.encode(value);
        default:
            throw TypeError('Unsupported format:' + String(typeof value));
    }
}
function hexify(bytes) {
    bytes = buffer(bytes, true);
    return bytesToHex(bytes);
}
function serialize(data) {
    if (typeof data === 'object') {
        if (data instanceof Uint8Array) {
            return data;
        }
        try {
            return strToBytes(JSON.stringify(data));
        }
        catch {
            throw TypeError('Object is not serializable.');
        }
    }
    return buffer(data, false);
}
function revive(data) {
    if (data instanceof Uint8Array) {
        data = bytesToStr(data);
    }
    if (typeof data === 'string') {
        try {
            return JSON.parse(data);
        }
        catch {
            return data;
        }
    }
    return data;
}
const Hex = {
    encode: (x) => bytesToHex(x),
    decode: (x) => hexToBytes(x),
    normalize: (x) => buffer(x),
    serialize: (x) => bytesToHex(buffer(x))
};
const Txt = {
    encode: (x) => bytesToStr(x),
    decode: (x) => strToBytes(x),
    serialzie: (x) => serialize(x),
    revive: (x) => revive(x)
};

function sha256(msg) {
    return sha256$1(buffer(msg));
}
function sha512(msg) {
    return sha512$1(buffer(msg));
}
function ripe160(msg) {
    return sha512$1(buffer(msg));
}
function hash256(msg) {
    return sha256$1(sha256$1(buffer(msg)));
}
function hash160(msg) {
    return ripemd160(sha256$1(buffer(msg)));
}
function hmac256(key, msg) {
    return hmac(sha256$1, buffer(key), buffer(msg));
}
function hmac512(key, msg) {
    return hmac(sha512$1, buffer(key), buffer(msg));
}
const Hash = {
    sha256,
    sha512,
    ripe160,
    hash256,
    hash160,
    hmac256,
    hmac512
};

const ec$1 = new TextEncoder();
const ALPHABETS = [
    {
        name: 'base58',
        charset: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    }
];
function getAlphabet(name) {
    for (const alpha of ALPHABETS) {
        if (alpha.name === name) {
            return alpha.charset;
        }
    }
    throw TypeError('Charset does not exist: ' + name);
}
function encode$1(data, charset, padding = false) {
    if (typeof data === 'string')
        data = ec$1.encode(data);
    const alphabet = getAlphabet(charset);
    const len = alphabet.length;
    const d = [];
    let s = '', i, j = 0, c, n;
    for (i = 0; i < data.length; i++) {
        j = 0;
        c = data[i];
        s += (c > 0 || (s.length ^ i) > 0) ? '' : '1';
        while (j in d || c > 0) {
            n = d[j];
            n = n > 0 ? n * 256 + c : c;
            c = n / len | 0;
            d[j] = n % len;
            j++;
        }
    }
    while (j-- > 0) {
        s += alphabet[d[j]];
    }
    return (padding && s.length % 4 > 0)
        ? s + '='.repeat(4 - s.length % 4)
        : s;
}
function decode$1(encoded, charset) {
    const alphabet = getAlphabet(charset);
    const len = alphabet.length, d = [], b = [];
    encoded = encoded.replace('=', '');
    let i, j = 0, c, n;
    for (i = 0; i < encoded.length; i++) {
        j = 0;
        c = alphabet.indexOf(encoded[i]);
        if (c < 0) {
            throw new Error(`Character range out of bounds: ${c}`);
        }
        if (!(c > 0 || (b.length ^ i) > 0))
            b.push(0);
        while (j in d || c > 0) {
            n = d[j];
            n = n > 0 ? n * len + c : c;
            c = n >> 8;
            d[j] = n % 256;
            j++;
        }
    }
    while (j-- > 0) {
        b.push(d[j]);
    }
    return new Uint8Array(b);
}
function addChecksum(data) {
    const sum = hash256(data);
    return joinArray([data, sum.slice(0, 4)]);
}
function checkTheSum(data) {
    const ret = data.slice(0, -4);
    const chk = data.slice(-4);
    const sum = hash256(ret).slice(0, 4);
    if (sum.toString() !== chk.toString()) {
        throw new Error('Invalid checksum!');
    }
    return ret;
}
const BaseX = {
    encode: encode$1,
    decode: decode$1
};
const Base58 = {
    encode: (data) => BaseX.encode(data, 'base58'),
    decode: (data) => BaseX.decode(data, 'base58')
};
const Base58C = {
    encode: (data) => {
        const withSum = addChecksum(data);
        return BaseX.encode(withSum, 'base58');
    },
    decode: (data) => {
        const decoded = BaseX.decode(data, 'base58');
        return checkTheSum(decoded);
    }
};

const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
const ENCODINGS = [
    { version: 0, name: 'bech32', const: 1 },
    { version: 1, name: 'bech32m', const: 0x2bc830a3 }
];
function polymod(values) {
    let chk = 1;
    for (let p = 0; p < values.length; ++p) {
        const top = chk >> 25;
        chk = (chk & 0x1ffffff) << 5 ^ values[p];
        for (let i = 0; i < 5; ++i) {
            if (((top >> i) & 1) !== 0) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
}
function hrpExpand(hrp) {
    const ret = [];
    let p;
    for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) >> 5);
    }
    ret.push(0);
    for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) & 31);
    }
    return ret;
}
function verifyChecksum(hrp, data, enc) {
    const combined = hrpExpand(hrp).concat(data);
    return polymod(combined) === enc.const;
}
function createChecksum(hrp, data, enc) {
    const values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
    const mod = polymod(values) ^ enc.const;
    const ret = [];
    for (let p = 0; p < 6; ++p) {
        ret.push((mod >> 5 * (5 - p)) & 31);
    }
    return ret;
}
function convertBits(data, fromBits, toBits, pad = true) {
    const ret = [];
    let acc = 0;
    let bits = 0;
    const maxVal = (1 << toBits) - 1;
    const maxAcc = (1 << (fromBits + toBits - 1)) - 1;
    for (const val of data) {
        if (val < 0 || (val >> fromBits) > 0) {
            throw new Error('Failed to perform base conversion. Invalid value: ' + String(val));
        }
        acc = ((acc << fromBits) | val) & maxAcc;
        bits += fromBits;
        while (bits >= toBits) {
            bits -= toBits;
            ret.push((acc >> bits) & maxVal);
        }
    }
    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toBits - bits)) & maxVal);
        }
    }
    else if (bits >= fromBits || ((acc << (toBits - bits)) & maxVal) > 0) {
        throw new Error('Failed to perform base conversion. Invalid Size!');
    }
    return ret;
}
function encode(hrp, data, enc) {
    const combined = data.concat(createChecksum(hrp, data, enc));
    let ret = hrp + '1';
    for (let p = 0; p < combined.length; ++p) {
        ret += CHARSET.charAt(combined[p]);
    }
    return ret;
}
function decode(bechstr) {
    if (!checkBounds(bechstr)) {
        throw new Error('Encoded string goes out of bounds!');
    }
    bechstr = bechstr.toLowerCase();
    if (!checkSeparatorPos(bechstr)) {
        throw new Error('Encoded string has invalid separator!');
    }
    const data = [];
    const pos = bechstr.lastIndexOf('1');
    const hrp = bechstr.substring(0, pos);
    for (let p = pos + 1; p < bechstr.length; ++p) {
        const d = CHARSET.indexOf(bechstr.charAt(p));
        if (d === -1) {
            throw new Error('Character idx out of bounds: ' + String(p));
        }
        data.push(d);
    }
    const enc = ENCODINGS.find(e => e.version === data[0]) ?? ENCODINGS[0];
    if (!verifyChecksum(hrp, data, enc)) {
        throw new Error('Checksum verification failed!');
    }
    return [hrp, data.slice(0, data.length - 6)];
}
function checkBounds(bechstr) {
    let p;
    let char;
    let hasLower = false;
    let hasUpper = false;
    for (p = 0; p < bechstr.length; ++p) {
        char = bechstr.charCodeAt(p);
        if (char < 33 || char > 126) {
            return false;
        }
        if (char >= 97 && char <= 122) {
            hasLower = true;
        }
        if (char >= 65 && char <= 90) {
            hasUpper = true;
        }
    }
    if (hasLower && hasUpper)
        return false;
    return true;
}
function checkSeparatorPos(bechstr) {
    const pos = bechstr.lastIndexOf('1');
    return !(pos < 1 ||
        pos + 7 > bechstr.length ||
        bechstr.length > 90);
}
function b32encode(data, hrp = 'bc', version = 0) {
    const dat = [version, ...convertBits([...data], 8, 5)];
    const enc = ENCODINGS.find(e => e.version === version) ?? ENCODINGS[0];
    const str = encode(hrp, dat, enc);
    b32decode(str);
    return str;
}
function b32decode(str) {
    str = str.toLowerCase();
    const hrp = str.split('1', 1)[0];
    const [hrpgot, data] = decode(str);
    const decoded = convertBits(data.slice(1), 5, 8, false);
    const length = decoded.length;
    switch (true) {
        case (hrp !== hrpgot):
            throw new Error('Returned hrp string is invalid.');
        case (decoded === null || length < 2 || length > 40):
            throw new Error('Decoded string is invalid or out of spec.');
        case (data[0] > 16):
            throw new Error('Returned version bit is out of range.');
        default:
            return Uint8Array.from(decoded);
    }
}
function getVersion(str) {
    str = str.toLowerCase();
    const [_, data] = decode(str);
    return data[0];
}
const Bech32 = {
    encode: b32encode,
    decode: b32decode,
    version: getVersion
};

const BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const B64URL_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
const ec = new TextEncoder();
function b64encode(input, urlSafe = false) {
    if (typeof input === 'string')
        input = ec.encode(input);
    const map = urlSafe ? B64URL_MAP : BASE64_MAP;
    let output = '';
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < input.length; i++) {
        buffer = (buffer << 8) | input[i];
        bits += 8;
        while (bits >= 6) {
            bits -= 6;
            output += map[(buffer >> bits) & 0x3f];
        }
    }
    if (bits > 0) {
        buffer <<= 6 - bits;
        output += map[buffer & 0x3f];
        while (bits < 6) {
            output += urlSafe ? '' : '=';
            bits += 2;
        }
    }
    return output;
}
function b64decode(input, urlSafe = false) {
    const map = (urlSafe || input.includes('-') || input.includes('_'))
        ? B64URL_MAP.split('')
        : BASE64_MAP.split('');
    input = input.replace(/=+$/, '');
    const chars = input.split('');
    let bits = 0;
    let value = 0;
    const bytes = [];
    for (let i = 0; i < chars.length; i++) {
        const c = chars[i];
        const index = map.indexOf(c);
        if (index === -1) {
            throw new Error('Invalid character: ' + c);
        }
        bits += 6;
        value <<= 6;
        value |= index;
        if (bits >= 8) {
            bits -= 8;
            bytes.push((value >>> bits) & 0xff);
        }
    }
    return new Uint8Array(bytes);
}
const Base64 = {
    encode: b64encode,
    decode: b64decode
};
const B64URL = {
    encode: (data) => b64encode(data, true),
    decode: (data) => b64decode(data, true)
};

class Buff extends Uint8Array {
    static { this.num = (number, size, endian = 'le') => {
        const b = new Buff(numToBytes(number), size);
        return (endian === 'le') ? b.reverse() : b;
    }; }
    static { this.big = (number, size, endian = 'le') => {
        const b = new Buff(bigToBytes(number), size);
        return (endian === 'le') ? b.reverse() : b;
    }; }
    static { this.bin = (data, size) => new Buff(binaryToBytes(data), size); }
    static { this.any = (data, size) => new Buff(buffer(data, false), size); }
    static { this.raw = (data, size) => new Buff(data, size); }
    static { this.str = (data, size) => new Buff(strToBytes(data), size); }
    static { this.hex = (data, size) => new Buff(hexToBytes(data), size); }
    static { this.json = (data) => new Buff(strToBytes(JSON.stringify(data))); }
    static { this.base64 = (data) => new Buff(Base64.decode(data)); }
    static { this.b64url = (data) => new Buff(B64URL.decode(data)); }
    static { this.bech32 = (data) => new Buff(Bech32.decode(data)); }
    static { this.b58chk = (data) => new Buff(Base58C.decode(data)); }
    static { this.bytes = (data, size) => new Buff(data, size); }
    constructor(data, size) {
        data = buffer(data, true);
        if (typeof size === 'number') {
            const tmp = new Uint8Array(size).fill(0);
            tmp.set(new Uint8Array(data));
            data = tmp.buffer;
        }
        super(data);
        return this;
    }
    get arr() {
        return [...this];
    }
    get num() {
        return this.toNum();
    }
    get big() {
        return this.toBig();
    }
    get str() {
        return this.toStr();
    }
    get hex() {
        return this.toHex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bits() {
        return this.toBits();
    }
    get bin() {
        return this.toBin();
    }
    get b58chk() {
        return this.tob58chk();
    }
    get base64() {
        return this.toBase64();
    }
    get b64url() {
        return this.toB64url();
    }
    get digest() {
        return this.toHash();
    }
    get id() {
        return this.toHash().hex;
    }
    get stream() {
        return new Stream(this);
    }
    toNum(endian = 'le') {
        return (endian === 'le')
            ? bytesToNum(this.reverse())
            : bytesToNum(this);
    }
    toBig(endian = 'le') {
        return (endian === 'le')
            ? bytesToBig(this.reverse())
            : bytesToBig(this);
    }
    toHash(type = 'sha256') {
        switch (type) {
            case 'sha256':
                return new Buff(Hash.sha256(this));
            case 'hash256':
                return new Buff(Hash.hash256(this));
            case 'ripe160':
                return new Buff(Hash.ripe160(this));
            case 'hash160':
                return new Buff(Hash.hash160(this));
            default:
                throw new Error('Unrecognized format:' + String(type));
        }
    }
    toHmac(key, type = 'hmac256') {
        switch (type) {
            case 'hmac256':
                return new Buff(Hash.hmac256(key, this));
            case 'hmac512':
                return new Buff(Hash.hmac512(key, this));
            default:
                throw new Error('Unrecognized format:' + String(type));
        }
    }
    toStr() { return bytesToStr(this); }
    toHex() { return bytesToHex(this); }
    toJson() { return JSON.parse(bytesToStr(this)); }
    toBytes() { return new Uint8Array(this); }
    toBits() { return bytesToBinary(this); }
    toBin() { return bytesToBinary(this).join(''); }
    tob58chk() { return Base58C.encode(this); }
    toB64url() { return B64URL.encode(this); }
    toBase64() { return Base64.encode(this); }
    toBech32(hrp, version = 0) { return Bech32.encode(this, hrp, version); }
    prepend(data) {
        return Buff.join([Buff.bytes(data), this]);
    }
    append(data) {
        return Buff.join([this, Buff.bytes(data)]);
    }
    slice(start, end) {
        return new Buff(new Uint8Array(this).slice(start, end));
    }
    subarray(begin, end) {
        return new Buff(new Uint8Array(this).subarray(begin, end));
    }
    reverse() {
        return new Buff(new Uint8Array(this).reverse());
    }
    write(bytes, offset) {
        this.set(bytes, offset);
    }
    prefixSize(endian) {
        const size = Buff.varInt(this.length, endian);
        return Buff.join([size, this]);
    }
    static from(data) {
        return new Buff(Uint8Array.from(data));
    }
    static of(...args) {
        return new Buff(Uint8Array.of(...args));
    }
    static join(arr) {
        const data = arr.map(e => Buff.bytes(e));
        return new Buff(joinArray(data));
    }
    static varInt(num, endian) {
        if (num < 0xFD) {
            return Buff.num(num, 1);
        }
        else if (num < 0x10000) {
            return Buff.of(0xFD, ...Buff.num(num, 2, endian));
        }
        else if (num < 0x100000000) {
            return Buff.of(0xFE, ...Buff.num(num, 4, endian));
        }
        else if (BigInt(num) < 0x10000000000000000n) {
            return Buff.of(0xFF, ...Buff.num(num, 8, endian));
        }
        else {
            throw new Error(`Value is too large: ${num}`);
        }
    }
    static { this.encode = strToBytes; }
    static { this.decode = bytesToStr; }
    static random(size = 32) {
        return new Buff(randomBytes(size), size);
    }
    static normalize(bytes, size) {
        return new Buff(buffer(bytes, true), size);
    }
    static hexify(bytes) {
        return hexify(bytes);
    }
    static serialize(data, size) {
        return new Buff(serialize(data), size);
    }
    static revive(data) {
        return revive(data);
    }
    static stringify(obj) {
        return JSON.stringify(obj, (_, v) => {
            return typeof v === 'bigint'
                ? `${v}n`
                : v;
        });
    }
    static parse(str) {
        return JSON.parse(str, (_, v) => {
            return typeof v === 'string' && /n$/.test(v)
                ? BigInt(v.slice(0, -1))
                : v;
        });
    }
}
class Stream {
    constructor(data) {
        this.data = new Uint8Array(data);
        this.size = this.data.length;
    }
    peek(size) {
        if (size > this.size) {
            throw new Error(`Size greater than stream: ${size} > ${this.size}`);
        }
        return new Buff(this.data.slice(0, size).buffer);
    }
    read(size) {
        size = size ?? this.readSize();
        const chunk = this.peek(size);
        this.data = this.data.slice(size);
        this.size = this.data.length;
        return chunk;
    }
    readSize(endian) {
        const num = this.read(1).num;
        switch (true) {
            case (num >= 0 && num < 0xFD):
                return num;
            case (num === 0xFD):
                return this.read(2).toNum(endian);
            case (num === 0xFE):
                return this.read(4).toNum(endian);
            case (num === 0xFF):
                return this.read(8).toNum(endian);
            default:
                throw new Error(`Varint is out of range: ${num}`);
        }
    }
}

const is = {
    null: x => x === null,
    undefined: x => typeof x === 'undefined',
    hex: x => isHex(x),
    string: x => typeof x === 'string',
    infinity: x => x === Infinity,
    bigint: x => typeof x === 'bigint',
    number: x => typeof x === 'number',
    class: x => (typeof x?.prototype === 'object' &&
        x.toString().startsWith('class')),
    function: x => typeof x === 'function',
    uint8: x => x instanceof Uint8Array,
    uint16: x => x instanceof Uint16Array,
    uint32: x => x instanceof Uint32Array,
    buffer: x => x instanceof ArrayBuffer,
    array: x => Array.isArray(x),
    object: x => typeof x === 'object'
};
const array = {
    isString: x => x.every((e) => is.string(e)),
    isNumber: x => x.every((e) => is.number(e)),
    isBigint: x => x.every((e) => is.bigint(e))
};
const type = (x) => {
    for (const [k, v] of Object.entries(is)) {
        if (v(x) === true) {
            return k;
        }
    }
    return 'unknown';
};
function isHex(str) {
    switch (true) {
        case (typeof str !== 'string'):
            return false;
        case (str.length % 2 !== 0):
            return false;
        case (/[^0-9a-fA-F]/.test(str)):
            return false;
        default:
            return true;
    }
}
const Check = {
    type,
    array,
    is
};

export { B64URL, Base58, Base58C, Base64, BaseX, Bech32, Buff, Check, Hash, Hex, Stream, Txt, addChecksum, b64decode, checkTheSum, hash160, hash256, hmac256, hmac512, ripe160, sha256, sha512 };
//# sourceMappingURL=module.mjs.map
